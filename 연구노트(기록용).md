# 연구노트

**좀 완벽한 파서를 구현해보자.**

* **참고사이트**
  * [셀레니움4 공식문서](https://www.selenium.dev/documentation/webdriver/browsers/chrome/)
  * [셀레니움-오류해결 공유](https://cat-minzzi.tistory.com/28)
  * **[ERDCloud](https://www.erdcloud.com/d/N8nnR7nSiPHhx4BpL)**
  
* 깃으로 형상관리
  * 보안을 위해 properties같은 파일에 따로 개인정보 기록
  * 보안을 위해 호스팅 서버에서만 동작하도록 리눅스 권한설정(properties 같은파일 접근할때 말함)
    * 이왕이면 url정보도 이렇게 숨기는게 안전할듯
  * 이정도만 하면 충분히 public으로 깃 관리해도 될듯(ㅇ.ㅇ)
* 기존 git-action 사용하던건??
  * 보통 코드 테스트용도로 많이쓰는걸로 아는데 이쪽으로 활용해보자.
  * 예로 그냥 로그인 필요없는 홈페이지 파싱같은건 쓸만하지 않겠나??
  * 정확히 어느정도 테스트에 쓰는지는 공부해보고 사용
* 유연하게 사용할 수 있는 파서가 되도록 구현해보자 -> 추후에 다른 사이트들에도 사용하기 쉽게끔
* 호스팅 서버에 python동작을 cgi로 할거냐 장고로 할거냐?
  * 호스팅 서버에 동작시킬건데 셀레니움으로 파서만 구현할테니까 그냥 cgi 방식으로 python 구동하면 될듯
* 성능개선은 ??
  * **멀티스레드, 멀티프로세스** 적용해서 구현하는걸로 하자
  * **Selenium Grid 4 (Docker Container)**: 하나의 script으로 원격 실행이 가능합니다. Docker의 Container를 사용해서 다수의 가상 머신에 Selenium을 배포하고 실행할 수 있습니다. 
    * 이거는 우선 넘어가고 나중에 도커를 잘 쓰게 될때 다시한번 체크해보자. 셀레니움4의 핵심추가기능

* 스케줄링(crontab) 으로 파서들 관리할 예정 -> 보통 하루 한번만 파싱하면 대부분 충분
  * 만약 자주 파싱해야할수도 있는 그런건 바로 파싱보다는 쿼리날려서 최신께 나왔는지 먼저 확인 필수
* **DB에는 데이터 저장을 할 것인가?? 아니면 xlsx?? -> DB**
  * DB가 개인적으로 관리하기 편해서 DB로 전부 데이터 관리하겠음.
  * 데이터 없는건 add하고 달라진건 update하고 등등 굿굿
* 네이버는 마지막에하고 **다른 사이트들 파싱 먼저!**

  * 단, 멀티스레드나 멀티프로세스 적용하면서 ㄱㄱ
  * 라이브러리도 최신껄로... 문법 무조건 다르니까 참고
  * 자바로할까 고민하긴했는데 보통 파이썬이 파싱하기엔 좋다고 하는듯

<br><br>

## 2023-10-09

**생각해보니 스마트스토어 동작을 짧게하려면 애초에 "기존방식대로" 해야함**

* **(참고)아이템_부속은 cascade로 외래키 묶기**
* **(1)네이버..로그인 -> 스마트스토어 product... 다운.. 읽기.. (기존 동일)**
  * product.xml사용하기 때문에 네이버 DB는 제거
* **(2)product.xml에 매칭(메모리비교) 데이터들만 분류 (기존 동일)**
* **(3)분류한 데이터들 DB데이터와 비교 및 연산 (기존꺼에서 DB저장으로)**
  * db에 없으면 insert + up필드 true + date필드(현재시간)
  * db에 있는데 동일하면 pass + up필드 false + date필드(현재시간)
  * db에 있는데 다르면 update + up필드 true + date필드(현재시간)
  * **(3-1)전부 비교후 date필드가 어제 날짜이전의 경우 delete**
* **(4)DB데이터 활용해서 스마트스토어 업데이트! up필드 true들만!! false는 바로 넘어가는거임!**

<br>



<br><br>

## 2023-10-06~08

폴더 구조화(고민), DB 구조화 등

<br>

**DB 설계는??**

* "파싱제품" 
  * 제품 Table {id, 제품명(쓰나모르겠), 모델명, 재고수, 판매상태}
  * 제품_parts Table {id, 외래키(제품), 모델명, 기타} -> "재고"를 제외한 "색깔, 사이즈, 부속품" 등이 더 있을때 기타로 추가!!
    * 제품:제품2 -> 1:N
  * 이렇게하면 재고수를 제외하고 얼마든지 더 DB기록 가능
  * 출력은 어차피 같은 모델 내용들 나열만 하면 됨ㅇㅇ.
* "기존제품"(네이버)
  * 제품_naver Table {id, 모델명, 판매상태, 외래키(제품)}
    * 제품3:제품 -> 1:1
* 단, 제품Table에서 Table명은 해당 파싱사이트 명으로!
  * 어차피 파싱사이트 이름으로 우린 스마트스토어에서 검색해서 수정하고있우니깡
* MySQL 로컬껄로... 진행해보자...
  * ERDCloud 에서 구현후 해당 create 코드 바로 사용해버리자.
  * **[ERDCloud](https://www.erdcloud.com/d/N8nnR7nSiPHhx4BpL)**
* **로컬호스트:3306에 root, 1234 & 디비 : parser**
* **저장??**
  * **(1)페이지 전체 아이템 순서무시 저장(+부속 같이) - 외래키도 연결 (cascade필수)**
    * 처음에는 insert가 엄청 많을수밖에 없음.
    * 이후에는 새로운제품 insert여서 작을거고, 재고다른거 update도 생기게 됨 or 사라진건 delete
      * update는 먼저 select로(desc,asc) 모든값 가져온 후 재고비교하고 다른것들 update함. 가능.
      * 단, 이게 좋을지 아니면 아예 delete후 전부새로 insert가 좋을지?
      * 그래도 이게좋을듯. 전부새로 insert는 insert 쿼리가 너무 많이 나갈듯..

    * 아마도 처음 insert 할때랑 update위해 **메모리에서 비교할때가 속도 느릴**거임.
      * 메모리 비교는 페이지 제품들의 순서는 잘 안바뀌는 특징을 이용해서 검색 속도를 올리자.

  * (2)네이버 아이템 저장(위에서구한 아이템 외래키도 연결) - cascade 필수
    * 처음부터 select로 위 아이템 전부가져온후 메모리 비교 후 네이버꺼 insert
      * 여기도 메모리 비교 검색 속도 최대한 올려보자ㅠ

    * 이후에는 select로 네이버꺼가져와 메모리비교후 새로운제품 insert나, 제품 사라진거 delete
      * 네이버는 특히 새로운거올리면 이전꺼 이후로 올라오므로 이걸로 메모리 검색속도 올리자!

* **조회??**
  * DB구조로 다 저장되어 있다면 조회는 join으로 간단히 한번에 다가져와 사용하면됨 - 네이버테이블


<br>

폴더 구조화-> 그냥 개발하면서 되는대로 하겠음!

**깃으로 형상관리 -> properties만 구성하고 바로 하겠음 또는 env던지 -> env로 선택**

* .gitignore 을 git이 인식 못하는것 같을때 캐시삭제 후 다시 push

  ```bash
  git rm -r --cached .
  git add .
  git commit -m "fixed untracked files"
  ```

**프로젝트 생성.. -> 아나콘다로 환경설정..**

* `conda install pytz python-dotenv pandas openpyxl lxml selenium requests beautifulsoup4`

**logging 라이브러리 활용 -> 로그레벨 사용**

**셀레니움 테스트는 터미널을 따로 켜서 따로 함으로써 빠르게 하자.**

**셀레니움 wait은 time.sleep, implicitly_wait은 사용X -> "Explicitly Wait 사용"**

* 최초 드라이버 생성 때 설정(Implicitly_Wait 기본값:0) : `driver.implicitly_wait(10)`
  * 10초전에 전체 DOM 로드시 더 안기다리고 바로 다음코드 진행
  * 10초 지나도 로드 안되면 예외
  * 추가로 timeout으로 설정된 시간 만큼 최대한 대기후 timeout Exception으로 넘어 갑니다.
* 매번 필요할때 사용(Explicitly Wait) : `WebDriverWait(browser, 5).until(EC.presence_of_element_located((By.XPATH, "//*[@id='maker_name']")))`
  * 5초전에 해당 엘리멘트 로드시 더 안기다리고 바로 다음코드 진행
  * 5초 지나도 로드안되면 예외
  * 추가로 timeout으로 설정된 시간 만큼 최대한 대기후 timeout Exception으로 넘어 갑니다.
* Explicitly Wait 가 코드는 복잡해져도,, 디버깅은 수월해지므로 오류검출 쉽게끔 이녀석만 사용하겠음
  * 딱히 timeout은 따로 안쓰겠다.
  * **시간초과 예외처리는 try catch로! 근데, 애초에 중간에 터지면 프로그램 다시 처리해야하다보니 try catch많이 안쓸듯** 

**셀레니움 엘리멘트 값 없을때 잘 넘어가기 위해 elements를 주로 써서 빈값은 []로 받자**

**정적해결되면은 request 라이브러리 사용, 동적은 셀레니움 사용!!**

* **특히 로그인 필요사이트는 셀레니움 -> `request.Session` 사용!!**
* **셀레니움으로 물론 다 가능하지만 request가 훨씬 속도는 빠르기 때문에 사용가능하면 꼭 쓰자.**
